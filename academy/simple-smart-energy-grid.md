import { Button, Alert, Link } from '@chakra-ui/react'

## Introduction

Welcome to this tutorial on creating a DePIN project using W3bstream and blockchain. We will build a simple smart energy grid that rewards energy-efficient users. With the increasing demand for energy worldwide, it has become increasingly important to find innovative ways to conserve and manage energy. A smart energy grid is one such solution that can help promote responsible energy use and reduce wastage.

In this tutorial, we will guide you through the process of building a smart energy grid from scratch. We will start by creating three smart contracts on the IoTeX blockchain that will authorize smart energy meters to send energy consumption data, keep track of device-owner bindings, and implement an ERC20 token used for the actual crypto rewards.

We will then show you how to create a W3bstream project composed of an Applet, in the form of a WASM module built in AssemblyScript, that validates and stores incoming IoT data. The module will process the data every 24 hours to evaluate users behavior and trigger rewards on the blockchain. Finally, we will build a smart energy meter device simulator using Node.js to create some data and send it to our W3bstream project.

By the end of this tutorial, you will have gained valuable insights into DePIN and the skills needed to build a simple project that rewards users to promote responsible behaviors. With these skills, you will be able to expand upon the system in new and exciting ways.
So let's get started!

## Setting up the development environment

Before you can begin creating the project, you'll need to make sure you have the following:

- A blockchain wallet app that is compatible with the IoTeX or Ethereum network, such as [Metamask](https://metamask.io/) or [ioPay](https://iopay.me)
- Some test tokens on one of the blockchains supported by W3bstream (IoTeX, Ethereum, Polygon)
- Node.js installed on your system
- Git installed on your system

<Alert>
A quick tutorial on how to create and fund an IoTeX testnet account can be found [here](https://developers.iotex.io/community-posts/create-an-iotex-developer-account-and-fund-it-with-test-iotx-tokens)
</Alert>

Once you have these prerequisites, you can start by creating the necessary folders for the project. In your terminal, run the following commands:

```sh
mkdir -p simple-smart-grid/blockchain
mkdir -p simple-smart-grid/w3bstream
mkdir -p simple-smart-grid/simulator
```

These folders will contain the different components of the project:

1. The `blockchain` subfolder contains the smart contracts needed for the IoTeX or Ethereum blockchain, including the authorization contract, device-owner binding contract, and ERC20 token contract.
2. The `w3bstream` subfolder contains the W3bstream applet source code. The applet is written in AssemblyScript and validates and stores incoming IoT data, and processes the data every 24 hours to trigger rewards on the blockchain.
3. The `simulator` subfolder contains the W3bstream-compatible smart-meter device simulator written in Node.js. This simulator is used to create fake data and send it to the W3bstream project for testing purposes.

**You can find the full project repository at [https://github.com/simonerom/w3bstream-power-meter](https://github.com/simonerom/w3bstream-power-meter).**

## Creating the smart contracts

### Device Identity and Binding

Let's start with the smart contracts. Each DePIN project must implement some sort of device identity and ownership binding mechanisms. The device identity consists of managing a list of devices that are allowed to contribute their data to the project via a unique device ID. Like in any IoT ecosystem, device binding is a required mechanism that allows identifying what account owns a certain device and is therefore allowed to communicate and manage it. In addition, in a DePIN application, device binding is also required to identify the address of the device owner, who is usually the recipient of rewards, NFT tokens, and other on-chain assets minted as a result of the data generated by their devices.

Both of these mechanisms can be securely managed with the help of blockchain and an bare minimum example is available here:

https://github.com/machinefi/w3bstream-examples/tree/main/identity-binding

For the purpose of this tutorial, we will copy the example above our blockchain folder and then focus on adding the other contract specific to this project:

```sh
git clone https://github.com/machinefi/w3bstream-examples
cp -r w3bstream-examples/identity-binding/* simple-smart-energy/blockchain
cd simple-smart-energy/blockchain
npm install
```

### Token economy

For the token economy part of this DePIN project, we will perform all the rewards calculations inside the W3bstream logic, which will then query the device registry and binding contracts on-chain to mint rewards to the respective device owners by directly triggering an ERC20 token.

Let's add this ERC20 token contract to the project: inside the `blockchain/contracts` folder, let's create `ECOToken.sol`:

```solidity
// SPDX-License-Identifier: MIT
// Basic ERC20 token with minting and burning functions
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract ECOToken is ERC20, AccessControl {

    // Create a new role identifier for the minter role
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    // Create a new role identifier for the burner role
    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");

    constructor() ERC20("EcoFriendly Token", "ECO") {
        // Grant the contract deployer the default admin role: it will be able
        // to grant and revoke any roles
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function mint(address to, uint256 amount) public {
        require(hasRole(MINTER_ROLE, msg.sender), "Caller is not a minter");
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) public {
        require(hasRole(BURNER_ROLE, msg.sender), "Caller is not a burner");
        _burn(from, amount);
    }
}
```

Let's edit the `deploy.js`script inside the `blockchain/scripts` folder to add the instructions to deploy this contract in addition to the odther two.

Add the following lines at the end of the `main()` function just before the "Save config section":

```js
  // ECO Rewards token
  const ECOToken = await ethers.getContractFactory("ECOToken");
  console.log("\nDeploying ECOToken contract");
  const ecoToken = await ECOToken.deploy();

  console.log("ECOToken Contract")
  console.log("address:", ecoToken.address);

  // Save Config Section
```

In the Save config section, add the following line to make sure the token contract address is saved in the .env file:

```js
  // Save config section
  
  // Save the contract addresses to the config file
  config.ECOTOKEN_CONTRACT = ecoToken.address;
```

Before we can run the script to deploy our contracts, make sure you created a blokchain wallet account and funded it with some IOTX tokens. We can use the IoTeX testnet for our deployment. A quick tutorial on how to create and fund an IoTeX testnet account can be found here:

https://developers.iotex.io/community-posts/create-an-iotex-developer-account-and-fund-it-with-test-iotx-tokens

Let's export the private key of our developer address and we are ready to deploy all the contracts with:

```sh
expoty PRIVATE_KEY=61f4ef09...f330b2
npx hardhat run scripts/deploy.js  --network testnet
```

Output:

```js
Compiled 1 Solidity file successfully
Deploying contracts with the account: 0x00e27ACAF1d3D58861DF710719fc97C43fC976f6
Account balance: 113.902296  IOTX

Deploying DevicesRegistry contract
DevicesRegistry Contract
address: 0x1b215fB19733C49bf529b2E5C225d169fFb427fc

Deploying DeviceBinding contract
DeviceBinding Contract
address: 0xD4C853aEb247fa63348D82E16D9ac51D4dbDA0f9

Deploying ECOToken contract
EcoToken Contract
address: 0x51D65c3E614Be96ebb637b960aF147d75d8711a4

Deployment completed.
Contracts deployed at height: 19918062


Configuration saved to .env file
```

Once the deployment of the contracts is completed, we can find all relevant address inside the `.env` file:

```sh
cat .env
```

Output:

```js
REGISTRY_CONTRACT=0x1b215fB19733C49bf529b2E5C225d169fFb427fc
BINDING_CONTRACT=0xD4C853aEb247fa63348D82E16D9ac51D4dbDA0f9
DEPLOYED_HEIGHT=19918062
DEPLOYER_ADDRESS=0x00e27ACAF1d3D58861DF710719fc97C43fC976f6
```

These contract addresses will come in handy once we configure our W3bstream logic!

## Building the W3bstream project

### The device message protocol

The core part of any W3bstream project is the *Applet*, that defines the logic of our project to be executed by W3bstream. This logic will be in charge of processing the data incoming from smart energy meter devices.

We will create the applet using the *W3bstream Applet Kit* package for AssemblyScript, however, Before we can build the applet, we should clarify what data we expect our device to send us.

We decided to have only two types of messages that our device can send: a *data message* and a *rewards request message*.

### The data message

The data message contains energy consumption information and is sent to w3bstream in short intervals (e.g. 1 minute):

```json
{
    "data": {
        "sensor_reading": 0.421,
        "timestamp": 1682091108
    },
    "public_key": "0xabcd...321",
    "signature": "0432bef...c00"
}
```

where:

- `sensor_reading`: is the average power consumed by the user in the last interval (let's assume it's 1 minute)
- `timestamp`: is the time when the value has been computed, in UNIX timestamp format
- `public_key`: is the public key of the device, whose correspoinding private key is used by the device to sign the data message above. It will also serve as the unique  identity **device_id** of the device.
- `signature`: is the digital signature of the **data** object performed by the device using elliptic curve cryptography with curve **secp256r1**:
  secp256r1.sign(sha256.hash(\{"sensor_reading": 0.421,"timestamp": 1682091108\}))

### The rewards request message

The rewards request message looks contains no energy data: it's only a request to periodically ping our W3bstream logic to make it process rewards. Since rewards are calculated based on data accumulated every 24h, this message could be sent every 24h or more:

```json
{
    "data": {
        "device_id": "0xefgh...675",
        "timestamp": 1682091108
    },
    "public_key": "0xabcd...321",
    "signature": "0432bef...c00"
}
```

where:

- `device_id`: is the the public key of the device for which the rewards processing is requested
- `timestamp`: is the time when the request has been sent, in UNIX timestamp format
- `public_key`: is the public key of the requester, we assume to be the device itself, that is also supposed to sign the request
- `signature`: is the digital signature of the request (i.e. the **data** object) using elliptic curve cryptography with curve **secp256r1**

### Creating the applet

For the W3bstream logic, we will first create the Applet that receives, validates, and stores IoT data to finally process rewards every 24 hours. For this purpose, we will use the [W3bstream Applet Kit for AssemblyScript](https://docs.w3bstream.com/get-started/hello-world/w3bstream-applet-kits/assemblyscript).

Inside the `w3bstream` folder, let's create our AssemblyScript project with:

```sh
npm init -y
npm install --save-dev assemblyscript
npx asinit . -y
```

Install the W3bstream Applet KIT module:

```sh
npm install @w3bstream/wasm-sdk
npm run asbuild
```

Let's open our editor in the current folder and edit the file `assebly/index.ts`, delete all the content, and let's start creating our W3bstream applet.

We begin by importing some utility functions from the W3bstream Applet KIT:

```typescript
import { Log, GetDataByRID, JSON } from "@w3bstream/wasm-sdk";
// Note: The { alloc } export is required, until it's implemented inside the W3bstream host
export { alloc } from "@w3bstream/wasm-sdk";
```

Then we create the first of two handlers in our applet: the `receive_data` handler that is in charge of processing data messages: it will validate and store IoT data alongside the device id that generated it. In a later section we will see how to execute this handler each time a new data message is sent to our W3bstream project.

```typescript
// This handler will be executed each time a new data message is sent to our W3bstream project
export function handle_data(rid: i32): i32 {
  // validate fields
  let message_json = validateData(rid), "message fields validation failed");
  // Verify device signature
  validateDeviceIdentity(message_json);
  // Store the IoT data along with the device id 
  storeData(message_json);

  return 0;
}

```

We will add the required functions in a moment. The second handler, that we will call `handle_rewards_request`, is in charge of periodically processing IoT data stored for a certain device, and triggering rewards to the respective owner based on certain energy consumption behavior:

```typescript
// This handler will be executed each time a "rewards request" message is sent to our W3bstream project
export function handle_rewards_request(rid: i32) {
  // validate fields
  let message_json = validateRewardsRequest(rid);
  // Verify device signature
  validateDeviceIdentity(message_json);
  // process and trigger rewards for the device
  process_rewards(message_json);
}

```

For the sake of simpilcity, we will add all the functions in the same `index.ts` file, though it's advisable to split the AssemblyScript project into different modules.

Let's start from two utility functions, used to read the Blockchain contracts that we deployed in the first part of this tutorial. We want to be able to query the DeviceRegistry contract for a specific device public key, to know if it's an authorized device. Additionally, we want to query the DeviceBinding contract to know if and whom a certain device is bound to:

```typescript
// Verify that the device public key is authorized
function auth_device(device_id: String ): bool {
    const REGISTRY_CONTRACT = "0x1b215fB19733C49bf529b2E5C225d169fFb427fc";
    const ENCODED_CALL = 
        "0xa6fe66de000000000000000000000000" 
        + device_id.replace("0x","");
    Log("Calling contract: " + REGISTRY_CONTRACT + " with encoded call: " + ENCODED_CALL)    
    let ret = CallContract(4690, REGISTRY_CONTRACT, ENCODED_CALL);
    Log("Contract call returned: " + ret)
    return isDefined(ret);
}

// Get the owner of a specific device id
function get_device_owner(device_id: String ): String {
    const BINDING_CONTRACT = "0x1b215fB19733C49bf529b2E5C225d169fFb427fc";
    let ret = CallContract(
        4690,
        BINDING_CONTRACT,
        "0x459b23a4000000000000000000000000" + device_id.replace("0x",""));
    return ret;
}
```

The `CallContract` W3bstream function allows the call a *view* contract function and get the return value. It takes the ChainId (4690 for IoTeX Testnet), the smart contract address and the encoded function call. Due to the absence of Web3 libraries for AssemblyScript, the function call has been [manually encoded](https://abi.hashex.org/) and the only required argument is then appended.

Next, let's see the `validateDeviceIdentity` function. This function is in charge of two important steps: 1. Verify the signature of the IoT data message, to make sure the data has not been tampered with and to retrieve the public key of the device that signed the message, and 2. query the blockchain DeviceRegistry contract to make sure that the public key does actually correspond to an authorized device:

```Typescript
function validateDeviceIdentity(message_json: JSON.Obj) {
    // Get the public key from the message
    let public_key = message_json.getString("public_key")?.valueOf();
    // Get the signature from the message
    let signature = message_json.getString("signature");
    // Perform signature verification
    // ...No Crypto libraries are yet available in AssemblyScript
    // this is best performed in Rust or Go
    
    // Verify that the device public key is authorized
    assert(auth_device(public_key), "Device is not authorized");
    
    return message_json;
}
```

The next relevant function is `storeData`, that is in charge of storing the IoT data along with the device public key:

```typescript
function storeData(message_json: JSON.Obj) { 
    // Get the device public key
    let public_key = message_json.getString("public_key")?.valueOf();
    // Get the device data
    let data_json = message_json.get("data") as JSON.Obj;
    // Get the sensor reading
    let sensor_reading = data_json.getString("sensor_reading")?.valueOf();
    // Get the timestamp
    let timestamp = data_json.getString("timestamp")?.valueOf();
    // Store the data in the W3bstream SQL Database
    const value = ExecSQL(
        `INSERT INTO "data_table" (public_key,sensor_reading,timestamp) VALUES (?,?,?);`, 
        [new String(public_key?? ""), new String(sensor_reading?? ""), new String(timestamp?? "")]);
}
```

the last relevant function is the `processRewards`: this function is in charge of querying IoT data for a specific device, implement some "energy efficient behavior validation" in a 24h interval based on the data, and calculate the amount of rewards for the owner of the device:

```typescript
function process_rewards(message_json: JSON.Obj): i32 {
  // We will process rewards based on data sent in 24h intervals
  const SECONDS_24H = 60 * 60 * 24;
  // Get the device id that is requesting the rewards calculation
  let device_id = message_json.getString("device_id");
  // Get the timestamp of the request
  let request_time = message_json.getString("timestamp");
  // Fetch the latest request for this device
  let start_interval = getLastExecutionTime(device_id);
  // Build the 24h interval
  let end_interval = start_interval + SECONDS_24H;
  // Make sure 24h has passed
  assert(request_time >= end_interval, "Too early for rewards calculation (every 24h)");
  while (request_time >= end_interval) {
    // Evaluate energy consumption in the interval
    let tokens = process_rewards(device_id, start_interval, end_interval);
    start_interval = end_interval + 1;
    end_interval = start_interval + SECONDS_24H;
  }
}
```

Fields validation functions are pretty straightforward: they use the `JSON.Obj` class to validate each field:

```typescript
// Validates the fields of the IoT data message
function validateData(rid: i32): JSON.Obj { 
    // Get the device data message from the W3bstream host
    let message_string = GetDataByRID(rid);
    // Parse the data message into a JSON object
    let message_json = JSON.parse(message_string) as JSON.Obj;
    // Validate the message fields
    assert(message_json.has("public_key"), "public_key field is missing");
    assert(message_json.has("signature"), "device_signature field is missing");
    assert(message_json.has("data"), "data field is missing");
    let data_json = message_json.get("data") as JSON.Obj;
    assert(data_json.has("sensor_reading"), "sensor_reading field is missing");
    assert(data_json.has("timestamp"), "timestamp field is missing");

    return message_json;
} 

// Validates the fields of a rewards request message
function validateRewardsRequest(rid: i32): JSON.Obj { 
    // Get the device data message from the W3bstream host
    let message_string = GetDataByRID(rid);
    // Parse the data message into a JSON object
    let message_json = JSON.parse(message_string) as JSON.Obj;
    // Validate the message fields
    assert(message_json.has("public_key"), "public_key field is missing");
    assert(message_json.has("signature"), "device_signature field is missing");
    assert(message_json.has("data"), "data field is missing");
    let data_json = message_json.get("data") as JSON.Obj;
    assert(data_json.has("device_id"), "device_id field is missing");
    assert(data_json.has("timestamp"), "timestamp field is missing");

    return message_json;
}
```

## Building the smart energy meter device simulator

```text
Work in progress
```

how to build the device simulator using Node.js. Discuss how the simulator generates data and sends it to the W3bstream project.

## Testing the system

```text
Work in progress
```

Test the entire system to ensure that everything is working as intended. This should include running the device simulator, sending data to the W3bstream project, and verifying that rewards are being triggered on the blockchain.

## Conclusion

Summarize what the reader has learned and provide some ideas for further exploration. Encourage the reader to experiment with the system and come up with new and innovative ways to use smart energy grids.
