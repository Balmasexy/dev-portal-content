---
title: Building an Energy-Efficient Smart Grid that Rewards Responsible Users with W3bstream, and the IoTeX Blockchain.
description: Learn how to create a DePIN project that enables the creation of a simple, smart energy grid. You'll be using cutting-edge technologies like W3bstream and IoTeX Blockchain to build a system that rewards users for their energy efficiency. By the end of this tutorial, you will have gained valuable insights into building an energy-efficient infrastructure that promotes responsible energy use.
path: academy/simple-smart-energy.md
---
import { Button, Alert, Link } from '@chakra-ui/react'

## Introduction

Welcome to this tutorial on creating a simple smart energy grid that rewards energy-efficient users using the IoTeX blockchain, W3bstream, and DePIN. With the increasing demand for energy worldwide, it has become increasingly important to find innovative ways to conserve and manage energy. A smart energy grid is one such solution that can help promote responsible energy use and reduce wastage.

In this tutorial, we will guide you through the process of building a smart energy grid from scratch. We will start by creating three smart contracts on the IoTeX blockchain that will authorize smart energy meters to send energy consumption data, keep track of device-owner bindings, and implement an ERC20 token used for the actual crypto rewards.

We will then show you how to create a W3bstream project composed of an Applet, in the form of a WASM module built in AssemblyScript, that validates and stores incoming IoT data. The module will process the data every 24 hours to evaluate users behavior and trigger rewards on the blockchain. Finally, we will build a smart energy meter device simulator using Node.js to create some data and send it to our W3bstream project.

By the end of this tutorial, you will have gained valuable insights into DePIN and the skills needed to build a simple project that rewards users to promote responsible behaviors. With these skills, you will be able to expand upon the system in new and exciting ways.
So let's get started!

## Setting up the development environment

Before you can begin creating the project, you'll need to make sure you have the following:

- A wallet that is compatible with the IoTeX or Ethereum network, such as Metamask or ioPay
- Some test tokens on one of the blockchains supported by W3bstream (IoTeX, Ethereum, Polygon)
- Node.js installed on your system
- Git installed on your system

Once you have these prerequisites, you can start by creating the necessary folders for the project. In your terminal, run the following commands:

```sh
mkdir -p simple-smart-grid/blockchain
mkdir -p simple-smart-grid/w3bstream
mkdir -p simple-smart-grid/simulator
```

These folders will contain the different components of the project:

1. The `blockchain` subfolder contains the smart contracts needed for the IoTeX or Ethereum blockchain, including the authorization contract, device-owner binding contract, and ERC20 token contract.
2. The `w3bstream` subfolder contains the W3bstream applet source code. The applet is written in AssemblyScript and validates and stores incoming IoT data, and processes the data every 24 hours to trigger rewards on the blockchain.
3. The `simulator` subfolder contains the W3bstream-compatible smart-meter device simulator written in Node.js. This simulator is used to create fake data and send it to the W3bstream project for testing purposes.

<Alert>
You can find the full project repository at https://github.com/simonerom/w3bstream-power-meter."
</Alert>

## Creating the smart contracts

### Device Identity and Binding

Let's start with the smart contracts. Each DePIN project must implement some sort of device identity and ownership binding mechanisms. The device identity consists of managing a list of devices that are allowed to contribute their data to the project via a unique device ID. Like in any IoT ecosystem, device binding is a required mechanism that allows identifying what account owns a certain device and is therefore allowed to communicate and manage it. In addition, in a DePIN application, device binding is also required to identify the address of the device owner, who is usually the recipient of rewards, NFT tokens, and other on-chain assets minted as a result of the data generated by their devices.

Both of these mechanisms can be securely managed with the help of blockchain and are described in this tutorial:
[link to the GitHub Repository]

For the purpose of this tutorial, we will copy the example above our blockchain folder and then focus on adding the other contract specific to this project:

```sh
git clone https://github.com/machinefi/w3bstream-examples
cp -r w3bstream-examples/identity-binding simple-smart-energy/blockchain
cd simple-smart-energy/blockchain
npm install
```

### Token economy

For the token economy part of this DePIN project, we will perform all the rewards calculations off-chain, inside the W3bstream logic, which will then send query the device registry and binding contracts to send rewards to the respective owners by directly triggering the minting of an ERC20 token.
Let's add this ERC20 token contract to the project: inside the blockchain/contracts folder, let's create `ECOToken.sol`:

```solidity
// Basic ERC20 token with minting and burning functions
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract ECOToken is ERC20, AccessControl {

    // Create a new role identifier for the minter role
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    // Create a new role identifier for the burner role
    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");

    constructor() ERC20("EcoFriendly Token", "ECO") {
        // Grant the contract deployer the default admin role: it will be able
        // to grant and revoke any roles
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function mint(address to, uint256 amount) public {
        require(hasRole(MINTER_ROLE, msg.sender), "Caller is not a minter");
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) public {
        require(hasRole(BURNER_ROLE, msg.sender), "Caller is not a burner");
        _burn(from, amount);
    }
}
```

## Building the W3bstream project

For the W3bstream logic, we will first create the Applet that receives, validates, and stores IoT data to finally process rewards every 24 hours. For this purpose, we will use the W3bstream Applet Kit for AssemblyScript (learn more at <https://docs.w3bstream.com/get-started/hello-world/w3bstream-applet-kits/assemblyscript>).

Inside the w3bstream folder, let's create our AssemblyScript project with:

```sh
npm init -y
npm install --save-dev assemblyscript
npx asinit . -y
```

Install the W3bstream Applet KIT module:

```sh
npm install @w3bstream/wasm-sdk
npm run as build
```

Edit the file `index.ts`inside the `assembly` folder, delete all the content, and let's start creating our applet.

We begin by importing some utility functions from the W3bstream Applet KIT:

```typescript
import { Log, GetDataByRID, JSON } from "@w3bstream/wasm-sdk";
```

Then we create the first of two handlers in our applet: the `receive_data` handler that is in charge of validating and storing IoT data:

```typescript
export function handle_data(rid: i32): i32 {
  // Get the IoT message
  const message = getMessage(rid);
  // Verify device signature
  validateSignature(message);
  // validate fields
  validateData(message);
  // Store the IoT data
  storeMessage(message);

  return 0;
}
```

We will add the required functions in a moment. The second handler, that we will call `handle_rewards_request`, is in charge of processing stored IoT data and triggering rewards to the respective owners based on certain energy consumption behavior:

```typescript
// Handles a process rewards request message. This message can be sent 
// periodically by the device itself.
export function handle_rewards_request(rid: i32): i32 {
  const SECONDS_24H = 60 * 60 * 24;
  // Get the IoT message
  const message = getMessage(rid);
  // Verify device signature
  validateSignature(message);
  // validate fields
  validateRewardsRequest(message);
  // Get the device id that is requesting the rewards calculation
  let device_id = message.getString("device_id");
  // Get the timestamp of the request
  let request_time = message.getString("timestamp");
  // Fetch the latest request for this device
  let start_interval = getLastExecutionTime(device_id);
  // Build the 24h interval
  let end_interval = start_interval + SECONDS_24H;
  // Make sure 24h has passed
  assert(request_time >= end_interval, "Too early for rewards calculation (every 24h)");
  while (request_time >= end_interval) {
    // Evaluate energy consumption in the interval
    let tokens = process_rewards(device_id, start_interval, end_interval);
    start_interval = end_interval + 1;
    end_interval = start_interval + SECONDS_24H;
  }
}
```
Let's start from the `getMessage()`, that would use the W3bstream KIT to obtain the actual data message from the W3bstream event:

```typescript
function getMessage(rid: i32): JSON.Obj {
  const payload_string = GetDataByRID(rid);
  return JSON.parse(message) as JSON.Obj;
}
```

For this project, we expect the device to send a data message with this format:

```json
{
    "data": {
        "sensor_reading": 0.421,
        "timestamp": 1682091108
    },
    "public_key": "0xabcd...321",
    "signature": "0432bef...c00"
}
```

where:

- `sensor_reading`: is the average power consumed by the user in the last 1 minute
- `timestamp`: is the time when the value has been computed, in UNIX timestamp format
- `public_key`: is the public key of the device, that will also serve as the unique device_id
- `signature`: is the digital signature of the `data` object using elliptic curve cryptography with curve `secp256r1`:
  
  ```typescript
    secp256r1.sign(sha256.hash(`{"sensor_reading": 0.421,"timestamp": 1682091108}`))
  ```

The next interesting function is `validateSignature(message)` that verifyis the signature in the message and authorize the device using the deviceRegistry on the blockchain. Let's start from importing the required package in AssemblyScript:

```typescript
import { crypto } from "as-wasm/crypto";

```

and here is the function:

```typescript
function validateSignature(message: JSON.Obj) {
  // Create an elliptic curve object for secp256r1
  const secp256r1 = new ec("secp256r1");

  // Convert the public key to bytes
  let publicKeyBytes = crypto.hexToBytes(message.getString("signature"));
  // Create an elliptic curve point object from the public key
  const publicKey = secp256r1.keyFromPublic(publicKeyBytes);

  // Convert the signature to bytes
  const signatureBytes = crypto.hexToBytes(message.getString("signature"));

  // Create the hash of the data message
  let messageHash = crypto.sha256(message.getObj("data").toString());

  // Verify the signature using the public key and the message hash
  const verified = crypto.verifySignature(publicKeyBytes, signatureBytes, messageHash);

  assert(verified, "Invalid IoT data message signature");
  
  Log("IoT data message signature is valid);

  // Check that the public key corresponds to an authorized device on the blockchain

}
```


The `validateData()` and `validateRewardsRequest()` functions will perform simple fields validation, and we will leave them out, the reader can find them into the project repository. The other function of interest is the `storeData(message)`that will use the W3bstream SQL database to store the data point. We will see how to configure the DB in the next chapter where we will talk about deploying our project to W3bstream, by now it's important to say that we will store the data and the device id it belongs to.


```typescript
<Alert>
  Work in progress
</Alert>
```


## Building the smart energy meter device simulator
<Alert>
Work in progress
</Alert>
how to build the device simulator using Node.js. Discuss how the simulator generates data and sends it to the W3bstream project.

## Testing the system
<Alert>
Work in progress
</Alert>
Test the entire system to ensure that everything is working as intended. This should include running the device simulator, sending data to the W3bstream project, and verifying that rewards are being triggered on the blockchain.

## Conclusion

Summarize what the reader has learned and provide some ideas for further exploration. Encourage the reader to experiment with the system and come up with new and innovative ways to use smart energy grids.
