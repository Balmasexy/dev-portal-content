# Introduction
In this tutorial we will describe how to generate verifiable IoT data that can power IoTeX Dapps from the Arduino Nano 33 IoT board. 

## Data message
Although this board integrates an accelerometer and a gyroscope, for the sake of simplicity for this tutorial we will just generate some "fake" data, pretending that the board is part of a device that is an heartrate onitor and we will just generate a simple data message where the data is composed of the heartrate measured at a specific time and the respective timestamp.

```js
{
  message: {
    heartreate: 64,
    timestamp: 1655734667,
    ...
  }
}
```

## Data signature
We make use of the ATECC608B secure crypto chip that is integrated in this board to generate and securely store a private key. While the correspondig public key can be used as a unique id to serve as a decentralized identity pointer, the chip itself will be used to securely sign the data message using the private key (the private key does never leave the chip).
Eventually, the data message will look like this:
```json
{
  "message": {
     "heartRate": 64, 
     "timestamp": 1655734985
   }, 
   "signature": "zE8Xpa0qzm2lqDSvLj14R04UnWEbAeP74o6ekrd5mc50DAfCNbDIAz7cG9+y4TVNGo2oWpc2fQnxm35LFJqB/hw=",
}
```

## Warning!
The ATECC608B chip provides elliptic curve digital signature using the **`secp256r1`** curve. Please notice that this is not compatible with IoTeX or Ethereum-compatible blockchain cryptography (which uses **`secp256k1`** instead). Therefore this board will never be able to sign valid blockchain transactions: make sure you don't use any "address" derived from the public key to receive crypto currencies as **they will be lost forever**.

# Requirements
To complete this tutorial you need:
- [IoT Nano 33 IoT board](https://docs.arduino.cc/hardware/nano-33-iot).
- The Arduino IDE configured to flash firmware onto the Nano 33 IoT board
- If you intend to use the data generated by the board into an IoTeX smart contract, it's highly recommended to also follow the [MachineFi Get Started guide](https://developers.iotex.io/posts/deploy-a-machinefi-dapp) to deploy a W3bStream node as the data storage and compute layer that serves Dapps on the blockchain.


# Configure the ATECC08 crypto chip

The ATECC608A needs to be configured and **locked** before it can be used. The [ArduinoECCX08 library](https://github.com/arduino-libraries/ArduinoECCX08) provides a [sketch that can be used to configure the chip](https://github.com/arduino-libraries/ArduinoECCX08/blob/master/examples/Tools/ECCX08CSR/ECCX08CSR.ino).  
In order to configure the chip, flash the [ECCX08CSR.ino](https://github.com/arduino-libraries/ArduinoECCX08/blob/master/examples/Tools/ECCX08CSR/ECCX08CSR.ino) sketch and follow the steps shown in the serial monitor. At the end, the device will produce a CSR (Certificate signing request). It is recommended to save this CSR for future use, but for the purposes of this example we will not be using certificates.  

# Coding the Sketch
The full code for this sketch is included in https://github.com/iotexproject/machinefi-getstarted-preview/blob/main/devices/nano-33-iot.ino

## Install dependencies

Using the Arduino library manager, install the following dependencies for the sketch:  

- [IoTeX-blockchain-client](https://www.arduino.cc/reference/en/libraries/iotex-blockchain-client/)
- [ArduinoMqttClient](https://www.arduino.cc/reference/en/libraries/arduinomqttclient/)
- [FlashStorage](https://www.arduino.cc/reference/en/libraries/flashstorage/)
- [WiFiNINA](https://www.arduino.cc/reference/en/libraries/wifinina/)
- [ArduinoECCX08](https://www.arduino.cc/reference/en/libraries/arduinoeccx08/)

Make sure you include them in your sketch:
```c++
#include <FlashStorage.h>
#include <FlashAsEEPROM.h>

#include <ArduinoMqttClient.h>
#include <WiFiNINA.h>
#include <IoTeX-blockchain-client.h>
#include <ArduinoECCX08.h>
```

Unfortunately, the ATECC608B does not support `keccak` hashing, so we imported the [IoTeX Blockchain client for Arduino](https://github.com/iotexproject/arduino-sdk) only to use the hashing function that it privides (we use it in `getDeviceId()`). 

## Configure the sketch
The next section can be used to confihure the MQTT endpoint intended to receive the data messages, and the WiFi network for the device to connect to the Internet:

```c++
// MQTT broker, eg. "test.mosquitto.org".
const char mqttBroker[] = "<YOUR_MQTT_BROKER>";
// MQTT port, eg. 1883. 
const int mqttPort = <YOUR_MQTT_PORT>;
// Wifi ssid.
const char wifiSsid[] = "<YOUR_WIFI_SSID>";
// Wifi password.
const char wifiPass[] = "<YOUR_WIFI_PASSWORD>";

WiFiClient wifiClient;
MqttClient mqttClient(wifiClient);
```

The ATECC608B crypto chip provides 16 slots that can be provisioned with a key pair: make sure you use the slot that you configured in the previous step. 

```c++
// The slot to use in the ATECC608A chip.
const int slot = 0;
```

Next we just have some global variables:
```c++
// Variables to store the deviceId and public key.
String deviceId = "";
byte publicKey[64] = {0};

// Variable to store the MQTT topic.
String topic = "";
```

## Connect to WiFi and to the MQTT broker
The Arduino's `setup()` function is used to first connect to the WiFi network, then connect to the MQTT broker where the data messages will be sent.
```c++
void setup() {
  Serial.begin(9600);
  while (!Serial);

  Serial.println("Verifiable IoT data from Arduino");
  Serial.println();

  // Init the ATECC608A crypto chip.
  if (!ECCX08.begin()) {
    Serial.println("Failed to communicate with ECC508/ECC608!");
    while (1);
  }

  // Verify the crypto chip is locked (ie. configured.).
  if (!ECCX08.locked()) {
    Serial.println("The ECC508/ECC608 is not locked!");
    Serial.println("ECC508/ECC608 needs to be configured and locked before proceeding");
    while (1);
  }

  // Connecto to the WiFi network.
  initWiFi();

  // Connect to the MQTT broker
  initMqtt();
  
  ...
```

## Generate the device unique id
The `setup()`function ends with the generation of a unique id for the device, by obtaining the public from the ATECC608B secure element
```c++
...
  // Retrieve the public key for the corresponding slot in the ECC508/ECC608.
  ECCX08.generatePublicKey(slot, publicKey);
...
```

then a convenient unique id can be created from the public key by hashing it and then taking say the last 20 bytes (see the `getDeviceId`function below). The unique id can then be used the foundation for a decentralized identity for this device on the IoTeX blockchain.
```c++
  // Generate the device id from the public key.
  deviceId = getDeviceId(publicKey);
  Serial.println  ("Device id: " + deviceId);
  topic = "/device/" + deviceId + "/data";
  Serial.print("Topic: ");
  Serial.println(topic);
}
```

We have also pre-computed an hypotetical the MQTT destination topic for data collection in the form of `/device/<id>/data`.

## Send verifiable data
The `loop()` function if finally in charge of generating some fake data, sign and send it to the MQTT broker.
The code is pretty self-explanatory, let's see it:

First we generate the data message using some fake data (these will be real sensors data in a production device):```
```c++
  // Build a message using a random heart rate value.
  String heartRate = String(ECCX08.random(150));
  // TODO Sync the RTC using WiFi and get the real epoch. Using a hardcoded one for now.
  String timestamp = "1655543438"; 
  String message = buildMessage(heartRate, timestamp);
```

Next, we hash the message (here, we used the hardware-accelerated SHA256 hashing function provided by the ATECC608B to hash the message)

```c++
  // Hash the message using sha256.
  byte hash[64] = {0};
  ECCX08.beginSHA256();
  ECCX08.endSHA256((byte*)message.c_str(), message.length(), hash);
```
we then use the ATECC608B to securely sign the message hash:

```c++
  // Sign the message using ECC cryptography + secp256r1 curve
  byte signature[64];
  ECCX08.ecSign(slot, hash, signature);
```

finally, we can use the mqtt client to send out the signed message:
```c++
  // Publish the message over MQTT.
  String mqttMessage = buildSignedMessage(message, signature, sizeof(signature));
  Serial.print("Sending mqtt message: ");
  Serial.println(mqttMessage);
  mqttClient.beginMessage(topic);
  mqttClient.print(mqttMessage);
  mqttClient.endMessage();
```

So to summarize:

1. Obtains the public key from the ATECC608A.
2. Calculate the device id from the public key. In our example application, device id is created in a similar way as Ethereum addresses (the last 20 bytes of the keccak256 hash of the public key). However, note that this is application specific. Any application can choose it's own process for creating device ids and use it later to verify device identities.
4. Produces a message with sensor data (fake heartrate and timestamp in our case).  
5. Get the sha256 hash of the message from the ATECC608A.   
6. Get the ECC signature of the message hash
7. The message along with the signature is sent to the server. The MQTT topic contains the device id so we do not include it in the message.

Check out the [MachineFi get started guide](https://developers.iotex.io/posts/deploy-a-machinefi-dapp) to learn how to deploy a Layer-2 network component that can receive ad verify IoT data, and use it to build proof of real-world facts that can then fuel blockchain MachineFi Dapps. 

# Utility functions
Let's also take a quick look at some relevant  utility functions included in the code:

`getDeviceId()`can be customized and it's only intended to generate a device unique id that is shorter than the public key itself (however, the public key would work as well).
So this functions simply takes the public key, hashes it using the keccak hashing algorithm and takes the last 20 bytes of the hash prefixed by "0x".
```c++
// Gets the device id from the public key.
String getDeviceId(const byte publicKey[64])
{
  uint8_t hash[IOTEX_HASH_SIZE] = {0};
  signer.getHash((const uint8_t*)publicKey, 64, hash);
  char hashLast20[41] = {0};
  signer.hex2str(hash + sizeof(hash) - 20, 20, hashLast20, 41);
  deviceId = "0x";
  deviceId += hashLast20;
  return deviceId;
}
```

`buildSignedMessage()` 

```c++
// Constructs a signed message from a message and a signature.
String buildSignedMessage(String message, byte* signature, int signatureSize)
{
  char base64Signature[signatureSize * 2] = {0};
  encoder.base64_encode((uint8_t*)signature, signatureSize, base64Signature);
  String messageWithSignature = "{\"message\":";
  messageWithSignature += message;
  messageWithSignature += ",\"signature\":\"";
  messageWithSignature += base64Signature;
  messageWithSignature += "\"}";
  return messageWithSignature;
}
```

`buildMessage()` just generated a formatted JSON object including the message and the signature, in the form that we have seen in the firs section of this tutorial:

```c++
// Builds a message given a heart rate value and timestamp.
String buildMessage(String heartRate, String timestamp)
{
  String message = "{\"heartRate\":";
  message += heartRate;
  message += ",\"timestamp\":";
  message += timestamp;
  message += "}";
  return message;
}
```





