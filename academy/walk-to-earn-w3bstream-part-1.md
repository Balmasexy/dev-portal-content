# "Walk to Earn" MachineFi Workshop

## About MachineFi

**MachineFi** is a methodology designed by IoTeX that allows the creation of decentralized financial applications based on data generated by smart devices in the physical world.

## About this workshop

In this workshop you'll learn the principles of MachineFi, from trusted data and trusted devices, to IoT token economies, and blockchain "proofs" based on IoT data. 
Based on these principles, you build a fully working MachineFi dApp using an Arduino board, a W3bstream node, and including a simple token economy on the IoTeX blockchain that rewards users with a cryptocurrency the more they walk/run in the real world.

## Prerequisites

Software:

- Git
- NodeJS 14
- Docker (with Compose)

- Arduino IDE
- Metamask Chrome Plugin

HArdware

- Arduino Nano 33 IoT

##Â References:

Below are some useful links to learn more:

- [MachineFi Vision Paper](https://machinefi.com)
- [W3bstream White Paper](https://)
- [W3bstream Documentation](docs.webstream.com)
- [IoTeX Documentation](https://docs.iotex.io)

## Components of a MachineFi dApp

Like any MachineFi dApp, this project is made of three components.

### The hardware component

For smart devices that have already existed in the market, it is usually difficult, if not impossible, to make significant changes to the manufacturing process as well as device firmware. However, newly designed ar repurposed from legacy ones could be designed with Blockchain in mind. 
Such Web3-oriented devices would have one or more of the following features:

- Is equipped with a piece of secure hardware
- Has a unique public/private key that can be used to derive a DID (decentralized Identity)
- Is equipped with a display to verify a blockchain address, and other UI elements for user interaction
- Supports secure OTA (over the air) firmware update

### The w3bstream component

1. Receives device's data and verifies data integrity
2. Uses blockchain to Authorize devices
3. Process/filter or do any IoT-related computation on the data
4. Store the data with multiple storage options (centralized or decentralized) and data retention policies
5. Sends "Proofs of Anything" (i.e., proofs of facts that happened in the real-world based on the IoT data) to blockchain applications

### The blockchain component

The blockchain component of a MachineFi dApp usually includes at least some incentivizing token economy, but more complex applications may implement decentralized marketplaces, have some DeFI elements like token staking, implement NFTs etc. Beside those,  "Authorization" contracts used to store DIDs of devices and devices-owner binding information is possibly also stored on-chain. 

Let's start from an overview of our project:

## Project overview

Let's call our MachineFi app "*WalkToEarn*". WalkToEarn is based on a **steps counter device**, a blockchain Dapp that uses an ERC20 token (our "cryptocurrency") to reward users, and a simple "Walk-to-Earn" token economy contract (that rewards users the more they walk), and of course, a w3bstream node that takes care of IoT data off-chain, and also uses a few smart contracts on the Blockchain to authorize devices when data arrives, and generate the "Proofs of walking" that are needed by the token economy contract.

## How does it work?

The step counter is a device that counts the number of steps when you carry it with you while walking. It just keeps accumulating the total number of steps, forever. Much like the odometer in a car, that keeps counting miles starting from zero, and forever. When first started it will count "0" steps, and the more you walk the more steps it adds up to the total. If you shut down the device, of course, it will not count but when you power it on again it will start from the last stored total value.
When the user does not walk, the device does nothing, but when the user walks , it keeps sending the current total number of steps to the blockchain oracle along with the timestamp, every 5 seconds (this could be improved, of course - e.g. by managing connection errors, last successfully sent data etc). This data is enough...

The W3bstream node, we receive these data messages `{ timestamp, totalSteps}` , do some integrity verification and device authorization, and we just store them in a local database.  We may implement some fancy IoT logic here. For example, we could ignore "short walks", or incentivize group of people walking together walking if we had a GPS on our device, but we'll make it easy and just reward all steps (feel free to improve the project!).

W3bstream uses two contracts on the blockchain:

A **device registry contract** that stores the unique ids of all the step counters, and the oracle uses this contract to make sure the data that it receives is actually coming from one our devices and not say from a fake device or even a software simulator this means we have pre-registered the ids of our devices to this contract).

We also have a **device binding contract** that binds each device to the blockchain wallet of the device owner. We need it because we do not reward the devices, we reward the owner 's wallet and typically a user can own multiple devices. So  when a user claims her rewards, the contract would need to know all the walking activity she did with any of her devices.
Finally, we have the actual token economy contracts, the Dapp. Of course, we have an ERC20 token that we use to send rewards to the users, and we have a "walk to earn" contract that users interact with to claim their rewards.

## The workflow

1. The user "buys" the step counter, which is bound to his wallet account by the manufacturer upon proof of ownership
2. The user does some walking activity, say he walks 10000 steps in 24 hours, which generates multiple messages (one every 5 seconds) from the device to the Iot oracle
3. The user opens the Dapp frontend and interacts with the WalkToEarn smart contract by "Claiming" his rewards
4. The smart contract will first make sure that the user does actually own one devices, then it emits an event that logs the request (device id, owner address, from when to when). 
5. The Oracle will detect the event and extract the request data from it, extract all steps data for that device in the requested timeframe, calculate the total number of steps and send it to the smart contract that will "credit" those steps to the user according to some incentive rule (e.g. 1 token per step).
6. Finally, the user can "Withdraw" his balance from the smart contract at any time.

## Let's get started

### Clone the project repository

```bash
git clone https://github.com/machinefi/w3bstream-examples
cd w3bstream-examples/walk2earn 
```

We have three folders, one for each component of our application:

- blockchain: contains the smart contracts and some scripts to interact with them once deployed.
- firmware: contains the sketch for the Arduino Nano 33 IoT board
- w3bstream: contains the w3bstream applet with the logic for the w3bstream node (device authorization and blockchain proofs generation)

### Deploy the smart contracts

In the blockchain folder we have all blockchain smart contracts required for this application: we use Hardhat tools to ease the deployment of the contracts and to interact with them from the command line.

#### Install Metamask

Before we can deploy to the blockchain we need a blockchain account (address & private key) and a few native tokens of the blockchain we are deploying to. We can use Metamask blockchain wallet to create a new account.

```bash
https://metamask.io/download/
```

Once the plugin is installed, just follow the initial account creation procedure, then go to the IoTeX developer portal to add the IoTeX Testnet to your Metamask wallet:

```bash
https://developers.iotex.io/utils/iotex-testnet
```

#### Claim IOTX test tokens

Since we are here, we can login into the Developer portal with our GitHub account, go to your dashboard, connect Metamask Wallet to the Portal, and claim some test IOTX tokens:

```
https://developers.iotex.io/user/profile
```

#### Export the private key

In Metamask, check the account details using the three vertical dots and select *Account Details*->*Export private key*, type your Metamask password, click *Confirm* and copy the private key to the clipboard:

```bash
export PRIVATE_KEY=<YOUR_PRIVATE_KEY_HERE>
```

The command below will install nodejs packages required for Hardhat and start the deployment of all contracts to the IoTeX testnet using the exported private key:

```bash
make deploy_contracts
```

at the end, all deployed contract addresses will be saved in a .env file, along with the curren blockchain height that we will need later.

### The W3bstream node

#### Run the node

Make sure you are in the same terminal where you exported the private key, so that it will be picked up by the w3bstream node too (for simplicity, we use the same blockchain account to deploy the contracts, for the w3bstream node and to receive rewards).

For this workshop, we want are using a specific release of W3bstream, v0.9.1. If you run into issues, you can build this same image locally with:

```
git clone 
git clone https://github.com/machinefi/w3bstream w3bstream-image
git checkout v0.9.1
make build_image
make run_image
```

Fetch the docker-compose.yaml file

```bash
mkdir docker && cd docker
curl https://raw.githubusercontent.com/machinefi/w3bstream/main/docker-compose.yaml > docker-compose.yaml
```

Run the node:

```bash
docker-compose -p w3bstream -f ./docker-compose.yaml up -d
cd ..
```

If this is the first time, this will pull all docker images required for the w3bstream node and finally run them. Once the node is started, in a different terminal, we can follow the w3bstream node logs:

```bash
docker container logs -f w3bstream 
```

Point your browser to the port 3000 to access the W3bstream studio dashboard:

```bash
localhost:3000
```

#### Build the W3bstream applet

Edit the W3bstream Applet, and make sure you replace the DeviceRegistry and WalkToEarn contract addresses inside `w3bstream/src/lib.rs`:

View deployed contract addresses:

```bash
cat blockchain/.env
```

edit lib.rs:

```rust
const CONTRACT_ADDR_DEVICES_REGISTRY: &str = "0x...";
const CONTRACT_ADDR_WALK_TO_EARN: &str = "0x...";
```

We can now build the W3bstream applet:

```
make applet
```

#### Deploy the Applet to the W3bstream node

Get back to the W3bstream Studio app, to create and configure the w3bstream node for this project. We can easily follot the W3bstream documentation:

1. [Create a project](https://docs.w3bstream.com/get-started/w3bstream-studio/creating-projects) and name it *WalkToEarn*
2. [Deploy the Applet](https://docs.w3bstream.com/get-started/w3bstream-studio/creating-projects) WASM we just built to the project (`w3bstream/target/wasm32-wasi/debug/walk2earn.wasm`), you can name this applet *Handlers*.
3. [Create a publisher](https://docs.w3bstream.com/get-started/w3bstream-studio/adding-publishers) with ID *stepcounter*
4. [Edit the default strategy](https://docs.w3bstream.com/get-started/w3bstream-studio/creating-strategies) and set the `EVENT_TYPE=STEPS_EVENT` and the action to `data_handler`
5. Create a new strategy with `EVENT_TYPE=CLAIM_EVENT` and action  `claim_handler`
6. [Run the applet](https://docs.w3bstream.com/get-started/w3bstream-studio/managing-applets-execution)
7. [Configure a smart contract monitor](https://docs.w3bstream.com/get-started/w3bstream-studio/monitoring-smart-contracts) to watch the WalkToEarn contract. Set `EVENT_TYPE=CLAIM_EVENT`, startHeight and contract address can be found in the `blockchain/.env file`, while the topic is the hash of the actual event we want to react to: in this case it's `0x766e6460a49ca518797200f8d2b455a80962f1e6acdcda61000fc3dc2004db88`. Since infinite monitor option is not available yet, For `StopHeight` we will just use a very high number.

### The device Firmware

Let's copy the firmware to the Arduino folders. By default, it's in user's Documents folder:

```bash
cp -r firmware/Arduino/* ~/Documents/Arduino/
```

Open the sketch in the Arduino IDE, and edit 

As a step counter, I will use an Arduino Nano 33 IoT board, because it's cheap, it integrates a secure element to make the device and its data verifiable according to the MachineFi methodology, and it integrated an accelerometer with a step-counting feature.
Pros: Secure element, integrated IMU, WiFi, cheap choice for building a PoC
Cons: poor set of integrated sensors, no GPS, no IoT cellular modem
Firmware explanation

I used the **pedometer functionality** integrated into the IMU. It counts the number of steps based only on the acceleration measured on the Z axis. But Every time the board is reset, the pedometer starts counting from 0 again. So, I store the current total number of steps in the flash. On every boot, the total steps counter variable is initialized with the last value stored in flash, and new steps get added from the IMU on top of it. So the device is just counting all steps, forever.

The integrated steps counter on the Nano 33 IoT board is not great: you can setup some acceleration thresholds to detect the steps, but there is no AI into the recognition of a step, so it's a bit limited. Also, it has only wifi, so in theory we should use the mobile phone to give it access to the internet. Better hardware should be used that includes cellular connection or at least low power bluetooth, and a GPS.  

### A look at the code

Here is the full code of the Arduino board firmware (I'll only focus on the more relevant functions, the rest are just utility functions):

```cpp
[ ... ]
// Configure your Wifi and MQTT endpoint
#include "secrets.h"

// Send messages with the MQTT protocol
#include <ArduinoMqttClient.h>

// Use accelerometer as a pedometer
#include <SparkFunLSM6DS3.h>
#include "Wire.h"
#include "SPI.h"

// Use the integrated secure crypto chip
#include <ArduinoECCX08.h>

[...]

void setup() {
  ...

  Serial.println("Initialize the pedometer...");
  if (!setupIMU()) {
    ...
  }

  Serial.print("Read total steps from flash...");
  steps = steps_storage.read();
  Serial.println(steps); 
  
  Serial.println("Initialize the secure crypto chip...");
  if (!ECCX08.begin()) {
    ..
  }

  // Verify the crypto chip is locked (ie. configured.).
  if (!ECCX08.locked()) {
    ...
  }

  // Connect to WiFi
  initWiFi();

  // Sync with Internet time 
  timeClient.begin();
  timeClient.update();
  ...

  // Connect to the MQTT Broker
  if (!initMqtt()) {
    ...
  }

  // Retrieve the public key from the secure crypto chip.
  ECCX08.generatePublicKey(slot, publicKey);
  String pubKey = BufferHexToStr(publicKey, sizeof(publicKey));
  Serial.print("Device's public key: " + pubKey);
  
  topic = "/device/" + pubKey + "/data";
  Serial.print("MQTT Topic: " + topic);
}

void loop() {
  // Wait for the accelerometer to accumulate steps 
  // ! not efficient, we should use deep sleep and wake up 
  while (!readSteps()) { 
     delay(3000);
  };

  readSteps();

  // Build a message using data from the accelerometer.
  Serial.println("\n---- NEW MESSAGE ----");
  
  // Get internet timestamp
  String timestamp = String(timeClient.getEpochTime()); 
  // Build the data message { "steps": "123", "timestamp": "12345678" }
  String message = buildMessage(steps, timestamp);

  // Hash the message using sha256.
  byte hash[32] = {0};
  ECCX08.beginSHA256();
  ECCX08.endSHA256((byte*)message.c_str(), message.length(), hash);
  Serial.println("Message hash is: "+ BufferHexToStr(hash, sizeof(hash)));

  // Sign the message.
  byte signature[64];
  ECCX08.ecSign(slot, hash, signature);
  Serial.println("Signature is " + BufferHexToStr(signature, sizeof(signature)));

  // Build the full message including digital signature
  String mqttMessage = buildSignedMessage(message, signature, sizeof(signature));
  // Sending the message over MQTT protocol
  Serial.print("Sending mqtt message: ");
  Serial.println(mqttMessage);
  mqttClient.beginMessage(topic);
  mqttClient.print(mqttMessage);
  mqttClient.endMessage();

  delay(3000);
  }
  
  ...
````

So the firmware works like this:

1. On boot, it will do initialization and read the last stored number of steps
2. In Loop, it will wait for the IMU to accumulate new steps
3. Read the total number of steps in the IMU and add up to the total steps
4. Save the new value of total steps in flash
5. Build the data JSON object
6. Use the secure crypto chip to sign the data object
7. Create the final message with data, signature and some more useful info
8. Send the message over to the W3bstream oracle using the MQTT protocol


